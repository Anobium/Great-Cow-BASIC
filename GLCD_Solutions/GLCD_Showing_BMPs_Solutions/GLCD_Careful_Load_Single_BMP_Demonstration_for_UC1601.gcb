'''A demonstration program for GCGB and GCB.
'''--------------------------------------------------------------------------------------------------------------------------------
'''This program is a simple GLCD demonstration of the UC1601 GLCD capabilities.
'''This program updates the GLCD with a BMP then updates the GLCD with a bar graph.
'''@author  EvanV
'''@licence GPL
'''@version 1.0
'''@date    27.08.2019
'''********************************************************************************

' ----- Configuration
#CHIP 16f18446, 32
#OPTION Explicit


' ----- Define GLCD Hardware settings
#INCLUDE <glcd.h>

#DEFINE GLCD_TYPE GLCD_TYPE_UC1601
'I2C address
#DEFINE GLCD_I2C_Address      0x70
'Hard Reset pin connection
#DEFINE GLCD_RESET            portc.0
#DEFINE GLCD_PROTECTOVERRUN
#DEFINE GLCD_OLED_FONT

'Generated by PIC PPS Tool for Great Cow Basic
'PPS Tool version: 0.0.5.20
'PinManager data: v1.65.2
'Generated for 16F18446
'
'Template comment at the start of the config file
'
#STARTUP InitPPS, 85
#DEFINE PPSToolPart 16F18446

Sub InitPPS

    'Module: MSSP1
    'SCL1 > RB7
    RB7PPS = 0x0013
    'RB7 > SCL1 (bi-directional)
    SSP1CLKPPS = 0x000F
    'SDA1 > RB5
    RB5PPS = 0x0014
    'RB5 > SDA1 (bi-directional)
    SSP1DATPPS = 0x000D

End Sub
'Template comment at the end of the config file

' ----- Define Hardware settings
' Define I2C settings - CHANGE PORTS if required for your specific device.
#DEFINE HI2C_BAUD_RATE 100
#DEFINE HI2C_DATA  PORTB.5
#DEFINE HI2C_CLOCK PORTB.7
'I2C pins need to be input for SSP module when used on this type of Microchip PIC device
Dir HI2C_DATA In
Dir HI2C_CLOCK In
HI2CMode Master


' ----- Main body of program commences here.  This is reusable code.

GLCDCLS

#INCLUDE "gcb.bmp"
' Table Name. This is required.  Just means you can reuse the BMP load code but referring your BMP to TableData
#DEFINE TableData GCB

' ----- Variables
' These must be WORDs as this a large table.    These are required!!
Dim TableReadPosition As Word
Dim TableLen As Word
Dim OBJWIDTH, OBJHEIGHT, GLCDXPOS, GLCDYPOS, OLDGLCDXPOS, WHOLEYBYTES, HCOUNT, GLCDY, WIDTHCOUNT, WBYTE, OPTMISEGLCDDRAW, ONPAGEBOUNDARY, GLCDX, CURRPAGE, MAXHEIGHT, l_CurrCharRow As Byte




' These must be WORDs as this a large table.
Dim TableReadPosition, TableLen As Word

' either 0 or 1.  Needs to match the background pixel state.
OptmiseGLCDDraw  = 0

' Start of code
TableReadPosition = 1
ReadTable TableData, TableReadPosition, objwidth: TableReadPosition++
ReadTable TableData, TableReadPosition, objHeight: TableReadPosition++

' sart draw at the upper left corner is set with GLCDXPos, GLCDYPos
GLCDXPos = 0
GLCDYPos = 0

oldGLCDXPos = GLCDXPos
'BMP file has the first piece of data at byte number 3.
TableReadPosition = 3

' Number of whole bytes within Y Axis.  This is integer maths!
WholeYBytes = objHeight /  8

' If GLCDYPos as a memory page boundary.  Used to fast write the byte
onPageBoundary = ( GLCDYPos % 8 ) = 0

'Do we have more than 8 rows of data - if so WholeYBytes <> 0
If WholeYBytes <> 0 Then

    ' counter to number of whole bytes
    For hCount = 0 To (WholeYBytes - 1)

        GLCDY = GLCDYPos+hCount
        ' increment thru bytes horizontally
        For widthCount = 0 To (objwidth - 1)
            ' get the next byte
            ReadTable TableData, TableReadPosition, wByte: TableReadPosition++
            ' if the incoming byte is the same as the background, dont draw
            If wByte <> OptmiseGLCDDraw Then
                ' So,  we have to draw this byte
                ' If a a page boundary  this is a faster draw routine
                If onPageBoundary = TRUE Then
                    ' just write the data out, no need to read whats there.
                    GLCDX = GLCDXPos+widthCount
                    Cursor_Position_UC1601 ( GLCDX , GLCDY )
                    Write_Data_UC1601 wByte

                Else
                    ' slow draw using X Y position and interate throught the bits
                    For l_CurrCharRow = 0 To 7
                        If wByte.0 = 0 Then
                            Pset GLCDXPos+widthCount, l_CurrCharRow + GLCDYPos, GLCDBackground
                        Else
                            Pset GLCDXPos+widthCount, l_CurrCharRow + GLCDYPos, GLCDForeground
                        End If
                        Rotate wByte Right
                    Next
                End If

            End If

        Next widthCount

        GLCDXPos =  oldGLCDXPos
        GLCDYPos = GLCDYPos + 8

    Next hCount

End If

' calculate the remaining bits to be dealt with in the BMP
maxHeight = objHeight % 8

'writes and remaining bits, if any
If maxHeight <> 0 Then

    For widthCount = 0 To objwidth - 1
        ReadTable TableData, TableReadPosition, wByte: TableReadPosition++
        ' slow draw using X Y position and interate throught the bits
        For l_CurrCharRow = 0 To maxHeight-1
            If wByte.0 = 0 Then
                Pset GLCDXPos+widthCount, ( l_CurrCharRow + GLCDYPos ), GLCDBackground
            Else
                Pset GLCDXPos+widthCount, ( l_CurrCharRow + GLCDYPos ), GLCDForeground
            End If
            Rotate wByte Right
        Next
    Next
End If


'Now update the GLCD

Dim mypos As Byte
Box 9,9, 55, 13

Do
    For mypos = 10 To 44
        FilledBox mypos, 10, mypos+10, 12, 1
        Wait 120 ms
        FilledBox  mypos, 10, mypos+10, 12, 0
        Wait 120 ms
    Next
    For mypos = 44 To 10
        FilledBox mypos, 10, mypos+10, 12, 1
        Wait 120 ms
        FilledBox  mypos, 10, mypos+10, 12, 0
        Wait 120 ms
    Next


Loop
End
