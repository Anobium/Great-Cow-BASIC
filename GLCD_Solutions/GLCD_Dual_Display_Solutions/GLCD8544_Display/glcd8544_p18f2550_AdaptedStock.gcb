'This program addresses both displays, it retains all the GCB GLCD capabilities but we need to initialise in a different way to support two screens.
'GCB uses a memory buffer to support the GLCD commands, therfore, you need to address one screen, update etc, then, update the other.  We only have one buffer to save memory but we have two displays.

#CHIP p18f2550,16
#OPTION Explicit

#INCLUDE <glcd.h>
'For this port we will enable the GLCD methods without the hardware specific driver, set type to 0!
'We get to use all GLCD commands but we need to do a bit of setup
#DEFINE GLCD_TYPE 0
#DEFINE GLCD_OLED_FONT

'Initialise global variable. Required variable for Circle in all DEVICE DRIVERS- DO NOT DELETE
Dim PCD8544_BufferLocationCalc As Word
Dim display As Byte
'For this port we need to create display buffer, this array needs to be created here as we dont initialise in the stock .h file.
Dim PCD8544_BufferAlias(504)


'For this port we need to specific a number of methods as local to this program
#STARTUP Local_InitGLCD_PCD8544, 85
'Map methods to hardware specific method
'These all exist in the default GLCD hardware driver so we need to point these methods at the local methods. Why? we support both displays.
#DEFINE GLCDCLS local_GLCDCLS_PCD8544
#DEFINE GLCDDrawChar GLCDDrawChar_PCD8544
#DEFINE FilledBox FilledBox_PCD8544
#DEFINE Pset Local_PSet_PCD8544
#DEFINE Write_Command_PCD8544 Local_Write_Command_PCD8544
#DEFINE Write_Data_PCD8544 Local_Write_Data_PCD8544
#DEFINE PCD8544WriteDelay 0
#DEFINE GLCD_WIDTH 84
#DEFINE GLCD_HEIGHT 48


' Pin mappings for SPI for Nokia 3310 Device
'For this port we need to rename GLCD_ to PCD8544_ so we can reuse all the functions and methods
#DEFINE PCD8544_DO portb.5
#DEFINE PCD8544_SCK portb.4
#DEFINE PCD8544_DC portb.6
#DEFINE PCD8544_CS1 portb.3
#DEFINE PCD8544_CS2 portb.2
#DEFINE PCD8544_RST portb.7

'Set other connected ports low
Dir portb.0 Out
portb.0 = Off

Repeat 2

    Call SelectDisplay1
    GLCDCLS
    Box 0,0,83,47
    Wait 1 s
    GLCDPrint( 5,5, "Display-1" )
    GLCDLocateString ( 8, 3)
    GLCDPrintStringLn ("Great Cow")
    GLCDPrintStringLn ("   BASIC")
    Wait 2 s
    FilledCircle ( 42, 24, 20 )
    Wait 1 s
    GLCDCLS
    FilledCircle ( 42, 24, 16 )
    Wait 500 ms
    GLCDCLS
    FilledCircle ( 42, 24, 12 )
    Wait 250 ms
    GLCDCLS
    FilledCircle ( 42, 24, 8 )
    Wait 125 ms
    GLCDCLS
    FilledCircle ( 42, 24, 4 )
    Wait 50 ms
    GLCDCLS

    Triangle 0, 0, 80,0, 8,40
    Wait 1 s

    FilledTriangle 5, 5, 62, 5, 12, 33
    Wait 2 s

    Call SelectDisplay2
    GLCDCLS
    Box 0,0,83,47
    Wait 1 s
    GLCDPrint( 5,5, "Display-2" )
    GLCDLocateString ( 8, 3)
    GLCDPrintStringLn ("Great Cow")
    GLCDPrintStringLn ("   BASIC")
    Wait 2 s
    FilledCircle ( 42, 24, 20 )
    Wait 1 s
    GLCDCLS
    FilledCircle ( 42, 24, 16 )
    Wait 500 ms
    GLCDCLS
    FilledCircle ( 42, 24, 12 )
    Wait 250 ms
    GLCDCLS
    FilledCircle ( 42, 24, 8 )
    Wait 125 ms
    GLCDCLS
    FilledCircle ( 42, 24, 4 )
    Wait 50 ms
    GLCDCLS

    Triangle 0, 0, 80,0, 8,40
    Wait 1 s

    FilledTriangle 5, 5, 62, 5, 12, 33
    Wait 2 s

End Repeat

'Animation section

Dim cc_x, c_x, c_y, d_x, d_y As Byte

'Animation
cc_x = 0
c_x = 0
c_y = 0
d_x = 0
d_y = 0

Call SelectDisplays
GLCDCLS
Call SelectDisplay1
Do
    Set PORTB.0 On
    animate
    Wait 200 ms

    Set PORTB.0 Off
    animate
    Wait 200 ms
Loop

Sub Animate
    If c_x => 78 Then
        If display = 1 Then
            Call SelectDisplay2
        End If
    Else
        If display = 2 Then
            Call SelectDisplay1
        End If
    End If

    GLCDPrint( cc_x, c_y, " " )

    If d_x = 0 Then
        c_x += 6
    Else
        c_x -= 6
    End If

    If d_y = 0 Then
        c_y += 1
    Else
        c_y -= 1
    End If

    If c_y >= 39 Then
        d_y = 1
    End If
    If c_y = 0 Then
        d_y = 0
    End If

    If c_x >= 156 Then
        d_x = 1
    End If
    If c_x = 0 Then
        d_x = 0
    End If

    If c_x => 78 Then
        cc_x = c_x-84
        If display = 1 Then
            Call SelectDisplay2
        End If
    Else
        cc_x = c_x
        If display = 2 Then
            Call SelectDisplay1
        End If
    End If
    GLCDPrint( cc_x, c_y, "*" )

End Sub


End



'''Initialise the GLCD device - adapted from the stock method
Sub Local_InitGLCD_PCD8544


    'Pin directions
    'ERV adapted ports
    Dir PCD8544_CS1 Out
    Dir PCD8544_CS2 Out
    Dir PCD8544_DC Out
    Dir PCD8544_RST Out

    Dir PCD8544_DO Out
    Dir PCD8544_SCK Out



    'Reset ports
    'ERV adapted ports
    PCD8544_CS1 = Off
    PCD8544_CS2 = Off
    Set PCD8544_DC Off
    Set PCD8544_RST Off
    Set PCD8544_DO Off
    Set PCD8544_SCK Off

    'Chip Select - will do both at once
    PCD8544_CS1 = Off
    PCD8544_CS2 = Off
    Wait 10 ms
    'Reset display
    Set PCD8544_RST On
    Wait 10 ms
    'Reset sequence (lower line for at least 10 us)
    Set PCD8544_RST Off
    Wait 25 us
    Set PCD8544_RST On
    Wait 10 ms
    PCD8544_CS1 = On
    PCD8544_CS2 = On
    Wait 10 us
    PCD8544_CS1 = Off
    PCD8544_CS2 = Off
    Wait 10 ms

' /*********SEE DATASHEET FOR ALL THIS********/

    PCD8544_CS1 = Off
    PCD8544_CS2 = On
    '     Activate Chip and H=1.
    Write_Command_PCD8544(0x21)
    '     Activate Chip and H=1.
    Write_Command_PCD8544(0x21)
    '     Set LCD Voltage to about 7V.
    Write_Command_PCD8544(0xC2)
    '     Adjust voltage bias.
    Write_Command_PCD8544(0x13)
    '     Horizontal addressing and H=0.
    Write_Command_PCD8544(0x20)
    '     Activate all segments.
    Write_Command_PCD8544(0x09)
    '               Erase all pixel on the DDRAM.
    Clear_RAM_PCD8544
    '     Blank the Display.
    Write_Command_PCD8544(0x08)
    '     Display Normal.
    Write_Command_PCD8544(0x0C)
    '         Cursor Home.
    GOTO_Pixel_PCD8544(0,0)

    PCD8544_CS1 = On
    PCD8544_CS2 = Off
    '     Activate Chip and H=1.
    Write_Command_PCD8544(0x21)
    '     Activate Chip and H=1.
    Write_Command_PCD8544(0x21)
    '     Set LCD Voltage to about 7V.
    Write_Command_PCD8544(0xC2)
    '     Adjust voltage bias.
    Write_Command_PCD8544(0x13)
    '     Horizontal addressing and H=0.
    Write_Command_PCD8544(0x20)
    '     Activate all segments.
    Write_Command_PCD8544(0x09)
    '               Erase all pixel on the DDRAM.
    Clear_RAM_PCD8544
    '     Blank the Display.
    Write_Command_PCD8544(0x08)
    '     Display Normal.
    Write_Command_PCD8544(0x0C)
    '         Cursor Home.
    GOTO_Pixel_PCD8544(0,0)

    'Colours
    GLCDBackground = 0
    GLCDForeground = 1
    GLCDFontWidth = 6
    GLCDfntDefault = 0
    GLCDfntDefaultSize = 1

    PCD8544_CS1 = Off
    PCD8544_CS2 = Off


End Sub



'''Draws a pixel on the GLCD
'''@param GLCDX X coordinate of pixel
'''@param GLCDY Y coordinate of pixel
'''@param GLCDColour State of pixel (0 = erase, 1 = display)
' adapted from the stock method
Sub Local_PSet_PCD8544(In GLCDX, In GLCDY, In GLCDColour As Word)

    Dim GLCDBitNo, GLCDChange, GLCDDataTemp As Byte
    Dim PCD8544_BufferLocationCalc As Word

    If GLCDX => GLCD_WIDTH Then Exit Sub
    If GLCDY => GLCD_HEIGHT Then Exit Sub

    'PCD8544_BufferLocationCalc = ( GLCDY / 8 )* GLCD_WIDTH

    'faster than /8
    PCD8544_BufferLocationCalc = GLCDY
    Repeat 3
        Set C Off
        Rotate PCD8544_BufferLocationCalc Right
    End Repeat
    PCD8544_BufferLocationCalc = PCD8544_BufferLocationCalc * GLCD_WIDTH

    PCD8544_BufferLocationCalc = GLCDX + PCD8544_BufferLocationCalc+1

    GLCDDataTemp = PCD8544_BufferAlias(PCD8544_BufferLocationCalc)

    'Change data to set/clear pixel
    GLCDBitNo = GLCDY AND 7
    If GLCDColour.0 = 0 Then
        GLCDChange = 254
        Set C On
    Else
        GLCDChange = 1
        Set C Off
    End If
    Repeat GLCDBitNo
        Rotate GLCDChange Left
    End Repeat

    If GLCDColour.0 = 0 Then
        GLCDDataTemp = GLCDDataTemp AND GLCDChange
    Else
        GLCDDataTemp = GLCDDataTemp OR GLCDChange
    End If

    If PCD8544_BufferAlias(PCD8544_BufferLocationCalc) <> GLCDDataTemp Then
        PCD8544_BufferAlias(PCD8544_BufferLocationCalc) = GLCDDataTemp
        Cursor_Position_PCD8544 ( GLCDX, GLCDY )
        Write_Data_PCD8544 ( GLCDDataTemp )
    End If

End Sub

'''Clears the GLCD screen
' adapted from the stock method
Sub local_GLCDCLS_PCD8544
    Dim PrintLocX, PrintLocY As Byte
    Dim PCD8544_BufferLocationCalc As Word
    GLCD_yordinate = 0
    PrintLocY = 0

    For PCD8544_BufferLocationCalc = 1 To 504
        PCD8544_BufferAlias(PCD8544_BufferLocationCalc) = 0x00
    Next

    '  'Goto the pixel specified by the Co-ordinate
    GOTO_Pixel_PCD8544(0,0)
    For PCD8544_BufferLocationCalc = 504 To 1 Step - 1
        Local_Write_Data_PCD8544( 0x00 )
    Next

    '  'Goto the pixel specified by the Co-ordinate
    GOTO_Pixel_PCD8544(0,0)
    PrintLocX = 0
    PrintLocY = 0
End Sub


Sub Local_Write_Command_PCD8544(In  PCD8544SendByte  )

    '   'Data/Command is set to zero to give Command of PCD8544 Controller
    Set PCD8544_DC Off
    '
    SPI_Send_Data_PCD8544(PCD8544SendByte)
    Wait PCD8544WriteDelay us
End Sub


Sub Local_Write_Data_PCD8544(In PCD8544SendByte )

    '        'Data/Command is set to One to give Data of PCD8544 Controller
    Set PCD8544_DC On
    SPI_Send_Data_PCD8544(PCD8544SendByte)

    Wait PCD8544WriteDelay us
End Sub


Sub SelectDisplay1
    PCD8544_CS1 = 0
    PCD8544_CS2 = 1
    display = 1

End Sub

Sub SelectDisplay2
    PCD8544_CS1 = 1
    PCD8544_CS2 = 0
    display = 2
End Sub

Sub SelectDisplays
    PCD8544_CS1 = 0
    PCD8544_CS2 = 0
    display = 3
End Sub
