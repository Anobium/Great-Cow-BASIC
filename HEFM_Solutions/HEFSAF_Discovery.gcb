' A Test Program to Discover HEF/SAF ACapabilities of
' a Specific PIC Microcontroller.
'
' Also Shows Constants that can be used in Source Code
'
' Copyright (C) 2019 William Roth

' This library is free software; you can redistribute it and/or
' modify it under the terms of the GNU Lesser General Public
' License as published by the Free Software Foundation; either
' version 2.1 of the License, or (at your option) any later version.

' This library is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
' Lesser General Public License for more details.

' You should have received a copy of the GNU Lesser General Public
' License along with this library; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
'
'''@author  William Roth and the works Evan Venn & Jacques Nilo
'''@licence GPL
'''@version 2.0
'''@date    08.11.2018
'''

'********************************************************************************
'

#CHIP 18F25K42, 16


'#chip 16F1769, 16
'

'#Chip 16F1518, 16


'#chip 16F1454, 16


'#chip 18F26K83, 16


#OPTION Explicit
'// Use with PPS Chips
#STARTUP InitPPS, 85

' Config UART
#DEFINE USART_BLOCKING TRUE
#DEFINE USART_BAUD_RATE 19200
'See InitPPS sub for TX Port/Pin

'--- Variables ---
Dim TMP_LONG As Long

'----- Main Code
Wait 500 ms

HSerPrintCRLF 2
HSerPrint "HEF - SAF Discovery"
HSerPrintCRLF 2
'Based upon constants read from Chipdata and HEFLASH.h
Call HEF_SAF_DISCOVER
End


'-------------- Sub Routines -----

Sub HEF_SAF_DISCOVER

#SCRIPT
    'Necessary if missing from datfile
    ChipHEFMemWords = ChipHEFMemWords + 0
    'Necessary if missing from datfile
    ChipSAFMemWords = ChipSAFMemWords + 0


    If ChipHEFMemWords = 128 AND ChipFamily = 15 Then
        '16F with HEF
        '16F with HEF and PMCON instead of NVMCON
        

        Erase_Row_Words = ChipEraseRowSizeWords
        'same as words on 16F
        Erase_Row_Bytes = ChipEraseRowSizeWords

        'Bytes for 16F
        F_ROWSIZE_BYTES = ChipEraseRowSizeWords
        'Words or Bytes
        F_WORDS = ChipHEFMemWords
        F_BYTES = ChipHEFMemWords
        F_START_ADDR = ChipWords - ChipHEFMemWords
        F_NUM_BLOCKS = ChipHEFMemWords / ChipEraseRowSizeWords

        If F_NUM_BLOCKS = 4  Then
            F_BLOCK0_ADDR = F_START_ADDR
            F_BLOCK1_ADDR = F_START_ADDR + 32
            F_BLOCK2_ADDR = F_START_ADDR + 64
            F_BLOCK3_ADDR = F_START_ADDR + 96
        End If

        If HEF_NUM_BLOCKS = 8  Then
            F_BLOCK0_ADDR = F_START_ADDR
            F_BLOCK1_ADDR = F_START_ADDR + 16
            F_BLOCK2_ADDR = F_START_ADDR + 32
            F_BLOCK3_ADDR = F_START_ADDR + 48
            F_BLOCK4_ADDR = F_START_ADDR + 64
            F_BLOCK5_ADDR = F_START_ADDR + 80
            F_BLOCK6_ADDR = F_START_ADDR + 96
            F_BLOCK7_ADDR = F_START_ADDR + 112
        End If
    End If

    If ChipSAFMemWords = 128 AND ChipFamily = 15 Then
        '16F with SAF and NVMCON instead of PMCON no TABLAT
        Erase_Row_Words = ChipEraseRowSizeWords
        Erase_Row_Bytes = ChipEraseRowSizeWords

        F_ROWSIZE_BYTES = ChipEraseRowSizeWords
        F_START_ADDR = ChipWords - ChipSAFMemWords
        F_WORDS = ChipSAFMemWords
        'Bytes
        F_BYTES = ChipSAFMemWords
        F_NUM_BLOCKS = ChipSAFMemWords / ChipEraseRowSizeWords

        If F_NUM_BLOCKS = 4 Then
            F_BLOCK0_ADDR = F_START_ADDR
            F_BLOCK1_ADDR = F_START_ADDR + 32
            F_BLOCK2_ADDR = F_START_ADDR + 64
            F_BLOCK3_ADDR = F_START_ADDR + 96
        End If
    End If

    If ChipSAFMemWords = 128 AND ChipFamily = 16  Then

        '18F with 256 bytes SAF - Uses Table Reads
        'Bytes
        ChipBytes = ChipWords * 2
        Erase_Row_Words = ChipEraseRowSizeWords
        Erase_Row_Bytes = ChipEraseRowSizeWords * 2

        F_ROWSIZE_BYTES = ChipEraseRowSizeWords * 2
        F_START_ADDR = (ChipWords * 2) - (ChipSAFMemWords * 2)
        F_WORDS = ChipSAFMemWords
        'Bytes
        F_BYTES = ChipSAFMemWords * 2
        F_NUM_BLOCKS = F_BYTES / Erase_Row_Bytes

        If F_NUM_BLOCKS = 2 Then
            F_BLOCK0_ADDR = F_START_ADDR
            F_BLOCK1_ADDR = F_START_ADDR + 128
        End If

        If F_NUM_BLOCKS = 4 Then
            F_BLOCK0_ADDR  = F_START_ADDR
            F_BLOCK1_ADDR  = F_START_ADDR + 64
            F_BLOCK2_ADDR  = F_START_ADDR + 128
            F_BLOCK3_ADDR  = F_START_ADDR + 192
        End If
    End If

#ENDSCRIPT

Dim TMP_LONG As Long

HSerPrint "Device: " : HSerPrint ChipNameStr
HSerPrintCRLF

HSerPrint "Chip Family: "
HSerPrint ChipFamily
HSerPrintCRLF

HSerPrint "Program Words: "
HSerPrint ChipWords
HSerPrintCRLF

HSerPrint "RAM Bytes: "
HSerPrint ChipRAM
HSerPrintCRLF

HSerPrint "PPS: "
#IFDEF Var(RA0PPS)
    HSerPrint "Yes"
#ENDIF

#IFNDEF Var(RA0PPS)
    HSerPrint "No"
#ENDIF
HSerPrintCRLF 2

#IF ChipHEFMemWords <> 128 AND ChipSAFMemWords <> 128
    HSerPrint ChipNameStr
    HSerPrint " Does Not Support HEF Or SAF"
    HSerPrintCRLF 2
#ENDIF

#IFDEF ChipHEFMemWords 128

    HSerPrint "---- Constants ----"
    HSerPrintCRLF 2

    HSerPrint "HEF_BYTES: "
    HSerPrint F_BYTES
    HSerPrintCRLF

    HSerPrint "HEF_ROWSIZE_BYTES: "
    HSerPrint F_ROWSIZE_BYTES
    HSerPrintCRLF

    HSerPrint "HEF_BLOCKS: "
    HSerPrint F_NUM_BLOCKS
    HSerPrintCRLF 2

    HSerPrint "HEF_BLOCK0_ADDR: "
    TMP_LONG = F_Block0_Addr
    HSerPrint Hex(TMP_LONG_H)
    HSerPrint Hex(TMP_LONG)
    HSerPrintCRLF

    HSerPrint "HEF_BLOCK1_ADDR: "
    TMP_LONG = F_Block1_Addr
    HSerPrint Hex(TMP_LONG_H)
    HSerPrint Hex(TMP_LONG)
    HSerPrintCRLF

    #IF F_NUM_BLOCKS > 2
        HSerPrint "HEF_BLOCK2_ADDR: "
        TMP_LONG = F_Block2_Addr
        HSerPrint Hex(TMP_LONG_H)
        HSerPrint Hex(TMP_LONG)
        HSerPrintCRLF

        HSerPrint "HEF_BLOCK3_ADDR: "
        TMP_LONG = F_Block3_Addr
        HSerPrint Hex(TMP_LONG_H)
        HSerPrint Hex(TMP_LONG)
        HSerPrintCRLF
    #ENDIF

    #IF F_NUM_BLOCKS > 4
        HSerPrint "HEF_BLOCK4_ADDR: "
        TMP_LONG = F_Block4_Addr
        HSerPrint Hex(TMP_LONG_H)
        HSerPrint Hex(TMP_LONG)
        HSerPrintCRLF

        HSerPrint "HEF_BLOCK5_ADDR: "
        TMP_LONG = F_Block5_Addr
        HSerPrint Hex(TMP_LONG_H)
        HSerPrint Hex(TMP_LONG)
        HSerPrintCRLF

        HSerPrint "HEF_BLOCK6_ADDR:"
        TMP_LONG = F_Block6_Addr
        HSerPrint Hex(TMP_LONG_H)
        HSerPrint Hex(TMP_LONG)
        HSerPrintCRLF

        HSerPrint "HEF_BLOCK7_ADDR:"
        TMP_LONG = F_Block7_Addr
        HSerPrint Hex(TMP_LONG_H)
        HSerPrint Hex(TMP_LONG)
        HSerPrintCRLF 2
    #ENDIF
    HSerPrint "---------------------"
#ENDIF

#IFDEF ChipSAFMemWords 128

    HSerPrint "---- Constants ----"
    HSerPrintCRLF 2

    HSerPrint "SAF_BYTES: "
    HSerPrint F_BYTES
    HSerPrintCRLF

    HSerPrint "SAF_ROWSIZE_BYTES: "
    HSerPrint F_ROWSIZE_BYTES
    HSerPrintCRLF

    HSerPrint "SAF_BLOCKS: "
    HSerPrint F_NUM_BLOCKS
    HSerPrintCRLF 2

    HSerPrint "SAF_BLOCK0_ADDR: "
    TMP_LONG = F_Block0_Addr
    HSerPrint Hex(TMP_LONG_H)
    HSerPrint Hex(TMP_LONG)
    HSerPrintCRLF

    HSerPrint "SAF_BLOCK1_ADDR: "
    TMP_LONG = F_Block1_Addr
    HSerPrint Hex(TMP_LONG_H)
    HSerPrint Hex(TMP_LONG)
    HSerPrintCRLF

    #IF F_NUM_BLOCKS > 2
        HSerPrint "SAF_BLOCK2_ADDR: "
        TMP_LONG = F_Block2_Addr
        HSerPrint Hex(TMP_LONG_H)
        HSerPrint Hex(TMP_LONG)
        HSerPrintCRLF

        HSerPrint "SAF_BLOCK3_ADDR: "
        TMP_LONG = F_Block3_Addr
        HSerPrint Hex(TMP_LONG_H)
        HSerPrint Hex(TMP_LONG)
        HSerPrintCRLF
    #ENDIF
    HSerPrint "---------------------"
#ENDIF

End Sub

Sub InitPPS

    #IFDEF ChipName 18F25K83, 18F26K83, 18F25K42, 18F26K42
        'TX1 > RC4
        RC4PPS = 0x0013
        'Clear TRIS control bit
        Dir PORTC.4 Out
    #ENDIF

    #IFDEF ChipName 16F1574, 16F1575, 16F1578, 16F1579
        'TX > RC4
        RC4PPS = 0x0009
    #ENDIF

    #IFDEF ChipName 16F1614, 16F618
        'TX > RC4
        RC4PPS = 0x0006
    #ENDIF

    #IFDEF ChipName 16F1615, 16F619
        'TX > RC4
        RC4PPS = 0x0012
    #ENDIF

    #IFDEF ChipName 16F15323, 16F15324, 16F155325, 16F15355
        'TX1 > RC4
        RC4PPS = 0x000F
    #ENDIF

    #IFDEF ChipName 16F15356, 16F15375, 16F15376
        'TX1 > RC4
        RC4PPS = 0x000F
    #ENDIF

    #IFDEF ChipName 16F1704, 16F1705, 16F1708, 16F1709
        'TX > RC4
        RC4PPS = 0x0014
    #ENDIF

    #IFDEF ChipName 16F1713, 16F1716, 16F1718, 16F1719
        'TX > RC4
        RC4PPS = 0x0014
    #ENDIF

    #IFDEF ChipName 16F1764, 16F1765, 16F1768, 16F1769
        'TX > RC4
        RC4PPS = 0x0016
    #ENDIF

    #IFDEF ChipName 16F1773, 16F1776, 16F1777, 16F1778, 16F1779
        'TX > RC4
        RC4PPS = 0x0024
    #ENDIF

End Sub
