'''A demonstration program for GCGB and GCB.
'''--------------------------------------------------------------------------------------------------------------------------------
'''This program combines the GLCD demonstration and CLC.
'''This shows how the switch input and the LED can be controlled without using the core microcontroller.
'''The LED changes state when the switch is depressed and there is no main user code.
'''
''' MPLAB® Xpress PIC16F18446 contains one mechanical button. This is a generic user configurable
''' button and when a button is pressed it will drive the I/O line to GND.
''' There is no pull-up resistor connected to the generic user button. So we enable
''' the internal pull-up in the PIC16F18446 to use the mechanical button.
'''
'''@author  EvanV
'''@licence GPL
'''@version 1.0
'''@date    7.7.2018
'''********************************************************************************

; ----- Configuration
    #chip 16f18446, 32
    #option explicit

    #include <glcd.h>

    #define LED0 porta.2    'Set a constant to refer to the LED.  RA2 is a Yellow LED called LED0 Edge connector, see section 3.3.1 of the MPLAB-Xpress-PIC16F18446-Evaluation-Board.pdf
    dir LED0 out            'Set LED as an output

    #define SW0 portc.2     'Set a constant to refer to the switch
    dir SW0 in              'Set the switch as an input
    WPUC2 = 1               'Enable weak pullup, see section 3.3.2 of the MPLAB-Xpress-PIC16F18446-Evaluation-Board.pdf

    'Generated by PIC PPS Tool for Great Cow Basic
    'PPS Tool version: 0.0.5.20
    'PinManager data: v1.65.2
    'Generated for 16F18446
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85
    #define PPSToolPart 16F18446

    Sub InitPPS

            'Module: MSSP1
            RB7PPS = 0x0013    'SCL1 > RB7
            SSP1CLKPPS = 0x000F    'RB7 > SCL1 (bi-directional)
            RB5PPS = 0x0014    'SDA1 > RB5
            SSP1DATPPS = 0x000D    'RB5 > SDA1 (bi-directional)
            'Module: CLC1
            RA2PPS = 0x0001    'CLC1OUT > RA2

    End Sub
    'Template comment at the end of the config file



; ----- Define Hardware settings
    ' Define I2C settings - CHANGE PORTS if required for your specific device.
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA  PORTB.5
    #define HI2C_CLOCK PORTB.7
    'I2C pins need to be input for SSP module when used on Microchip PIC device
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in

; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306
    #define GLCD_I2C_Address 0x78


; ----- Define CLC config
    'CLC Setting CLC1 or-xor to CLC1OUT which is the LED
    CLC1GLS0  = 0x02
    CLC1GLS1  = 0x00
    CLC1GLS2  = 0x00
    CLC1GLS3  = 0x00
    CLC1SEL0  = 0x00
    CLC1SEL1  = 0x13
    CLC1SEL2  = 0x01
    CLC1SEL3  = 0x13
    CLC1POL   = 0x00
    CLC1CON   = 0x81
    CLCIN0PPS = 0x12
    CLCIN1PPS = 0x00
    CLCIN2PPS = 0x00
    CLCIN3PPS = 0x00

; ----- Define variables

    Dim BYTENUMBER, CCOUNT as Byte

    CCount = 0
    dim longNumber as long
    longNumber = 123456 ' max value = 4294967290
    dim wordNumber as Word
    dim outstring as string
    wordNumber = 0
    byteNumber = 0

; ----- Main program

    GLCDPrint 0, 0,   "Great Cow BASIC"
    GLCDPrint (0, 11, "Anobium 2018")
    GLCDPrint (0, 23, "MPLAB Xpress Board")
    GLCDPrint (0, 35, "PIC"+ChipNameStr )
    GLCDPrint (0, 47, "I2C OLED SDD1306" )


    wait 3 s
    GLCDCLS

    ' Prepare the static components of the screen
    GLCDPrint ( 2,   1, "PrintStr")                                ; Print some text
    GLCDPrint ( 64,  1, "@")                                       ; Print some more text
    GLCDPrint ( 72,  1, ChipMhz)                                   ; Print chip speed
    GLCDPrint ( 86, 1, "Mhz")                                      ; Print some text
    box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1                            ; Draw a box
    box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1    ; Draw a box
    Circle( 44,41,15)                                              ; Draw a circle
    line 64,31,0,31                                                ; Draw a line

    DO forever

       for CCount = 32 to 127

            GLCDPrint ( 64 ,  36,  hex(longNumber_E ) )                 ; Print a HEX string
            GLCDPrint ( 76 ,  36,  hex(longNumber_U ) )                 ; Print a HEX string
            GLCDPrint ( 88 ,  36,  hex(longNumber_H ) )                 ; Print a HEX string
            GLCDPrint ( 100 ,  36, hex(longNumber   ) )                 ; Print a HEX string
            GLCDPrint ( 112 ,  36, "h" )                                ; Print a HEX string


            GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) )           ; Print a padded string
            GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) )           ; Print a padded string


            box (46,9,56,19)                                           ; Draw a Box
            GLCDDrawChar(48, 10, CCount )                               ; Draw a character
            outString = str( CCount )                                  ; Prepare a string
            GLCDDrawString(64, 10, pad(outString,3) )                   ; Draw a string

            filledbox 3,43,11,51, wordNumber                           ; Draw a filled box

            FilledCircle( 44,41,9, longNumber xor 1)                   ; Draw a filled box
            line 0,63,64,31                                            ; Draw a line

                                                                       ; Do some simple maths
            longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++

        NEXT

    LOOP
    end
