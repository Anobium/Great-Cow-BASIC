
AVRASM ver. 2.1.57  D:\Great-Cow-BASIC-Demonstration-Sources.git\trunk\Training_Support\AVRrc\ser1receive_tiny9\ser1receive_tiny9\ser1receive_tiny9.asm Sun Jun 14 07:50:10 2020

[builtin](2): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\tn9def.inc'
D:\Great-Cow-BASIC-Demonstration-Sources.git\trunk\Training_Support\AVRrc\ser1receive_tiny9\ser1receive_tiny9\ser1receive_tiny9.asm(9): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\tn9def.inc'
D:\Great-Cow-BASIC-Demonstration-Sources.git\trunk\Training_Support\AVRrc\ser1receive_tiny9\ser1receive_tiny9\ser1receive_tiny9.asm(33): warning: Register r26 already defined by the .DEF directive
D:\Great-Cow-BASIC-Demonstration-Sources.git\trunk\Training_Support\AVRrc\ser1receive_tiny9\ser1receive_tiny9\ser1receive_tiny9.asm(36): warning: Register r30 already defined by the .DEF directive
D:\Great-Cow-BASIC-Demonstration-Sources.git\trunk\Training_Support\AVRrc\ser1receive_tiny9\ser1receive_tiny9\ser1receive_tiny9.asm(37): warning: Register r31 already defined by the .DEF directive
D:\Great-Cow-BASIC-Demonstration-Sources.git\trunk\Training_Support\AVRrc\ser1receive_tiny9\ser1receive_tiny9\ser1receive_tiny9.asm(38): warning: Register r26 already defined by the .DEF directive
D:\Great-Cow-BASIC-Demonstration-Sources.git\trunk\Training_Support\AVRrc\ser1receive_tiny9\ser1receive_tiny9\ser1receive_tiny9.asm(39): warning: Register r27 already defined by the .DEF directive
D:\Great-Cow-BASIC-Demonstration-Sources.git\trunk\Training_Support\AVRrc\ser1receive_tiny9\ser1receive_tiny9\ser1receive_tiny9.asm(40): warning: Register r28 already defined by the .DEF directive
D:\Great-Cow-BASIC-Demonstration-Sources.git\trunk\Training_Support\AVRrc\ser1receive_tiny9\ser1receive_tiny9\ser1receive_tiny9.asm(41): warning: Register r29 already defined by the .DEF directive
D:\Great-Cow-BASIC-Demonstration-Sources.git\trunk\Training_Support\AVRrc\ser1receive_tiny9\ser1receive_tiny9\ser1receive_tiny9.asm(42): warning: Register r25 already defined by the .DEF directive
D:\Great-Cow-BASIC-Demonstration-Sources.git\trunk\Training_Support\AVRrc\ser1receive_tiny9\ser1receive_tiny9\ser1receive_tiny9.asm(44): warning: Register r29 already defined by the .DEF directive
D:\Great-Cow-BASIC-Demonstration-Sources.git\trunk\Training_Support\AVRrc\ser1receive_tiny9\ser1receive_tiny9\ser1receive_tiny9.asm(45): warning: Register r30 already defined by the .DEF directive
                 
                 ;Program compiled by Great Cow BASIC (0.98.<<>> 2020-06-07 (Windows 64 bit))
                 
                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny9.xml *************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "tn9def.inc"
                 ;* Title             : Register/Bit Definitions for the ATtiny9
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATtiny9
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _TN9DEF_INC_
                 #define _TN9DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATtiny9
                 #pragma AVRPART ADMIN PART_NAME ATtiny9
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x90
                 .equ	SIGNATURE_002	= 0x08
                 
                 #pragma AVRPART CORE CORE_VERSION AVR8L_0
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	CCP	= 0x3c
                 .equ	RSTFLR	= 0x3b
                 .equ	SMCR	= 0x3a
                 .equ	OSCCAL	= 0x39
                 .equ	CLKMSR	= 0x37
                 .equ	CLKPSR	= 0x36
                 .equ	PRR	= 0x35
                 .equ	VLMCSR	= 0x34
                 .equ	NVMCMD	= 0x33
                 .equ	NVMCSR	= 0x32
                 .equ	WDTCSR	= 0x31
                 .equ	GTCCR	= 0x2f
                 .equ	TCCR0A	= 0x2e
                 .equ	TCCR0B	= 0x2d
                 .equ	TCCR0C	= 0x2c
                 .equ	TIMSK0	= 0x2b
                 .equ	TIFR0	= 0x2a
                 .equ	TCNT0L	= 0x28
                 .equ	TCNT0H	= 0x29
                 .equ	OCR0AL	= 0x26
                 .equ	OCR0AH	= 0x27
                 .equ	OCR0BL	= 0x24
                 .equ	OCR0BH	= 0x25
                 .equ	ICR0L	= 0x22
                 .equ	ICR0H	= 0x23
                 .equ	ACSR	= 0x1f
                 .equ	DIDR0	= 0x17
                 .equ	EICRA	= 0x15
                 .equ	EIFR	= 0x14
                 .equ	EIMSK	= 0x13
                 .equ	PCICR	= 0x12
                 .equ	PCIFR	= 0x11
                 .equ	PCMSK	= 0x10
                 .equ	PORTCR	= 0x0c
                 .equ	PUEB	= 0x03
                 .equ	PORTB	= 0x02
                 .equ	DDRB	= 0x01
                 .equ	PINB	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture  Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR0 - 
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** CPU **************************
                 ; CCP - Configuration Change Protection
                 .equ	CCP0	= 0	; Configuration Change Protection bit 0
                 .equ	CCP1	= 1	; Configuration Change Protection bit 1
                 .equ	CCP2	= 2	; Configuration Change Protection bit 2
                 .equ	CCP3	= 3	; Configuration Change Protection bit 3
                 .equ	CCP4	= 4	; Configuration Change Protection bit 4
                 .equ	CCP5	= 5	; Configuration Change Protection bit 5
                 .equ	CCP6	= 6	; Configuration Change Protection bit 6
                 .equ	CCP7	= 7	; Configuration Change Protection bit 7
                 
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; CLKMSR - Clock Main Settings Register
                 .equ	CLKMS0	= 0	; Clock Main Select Bit 0
                 .equ	CLKMS1	= 1	; Clock Main Select Bit 1
                 
                 ; CLKPSR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; SMCR - Sleep Mode Control Register
                 .equ	SE	= 0	; Sleep Enable
                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                 
                 ; PRR - Power Reduction Register
                 .equ	PRTIM0	= 0	; Power Reduction Timer/Counter0
                 .equ	PRADC	= 1	; Power Reduction ADC
                 
                 ; VLMCSR - Vcc Level Monitoring Control and Status Register
                 .equ	VLM0	= 0	; Trigger Level of Voltage Level Monitor bit 0
                 .equ	VLM1	= 1	; Trigger Level of Voltage Level Monitor bit 1
                 .equ	VLM2	= 2	; Trigger Level of Voltage Level Monitor bit 2
                 .equ	VLMIE	= 6	; VLM Interrupt Enable
                 .equ	VLMF	= 7	; VLM Flag
                 
                 ; RSTFLR - Reset Flag Register
                 .equ	PORF	= 0	; Power-on Reset Flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; NVMCSR - Non-Volatile Memory Control and Status Register
                 .equ	NVMBSY	= 7	; Non-Volatile Memory Busy
                 
                 ; NVMCMD - Non-Volatile Memory Command
                 .equ	NVMCMD0	= 0	; 
                 .equ	NVMCMD1	= 1	; 
                 .equ	NVMCMD2	= 2	; 
                 .equ	NVMCMD3	= 3	; 
                 .equ	NVMCMD4	= 4	; 
                 .equ	NVMCMD5	= 5	; 
                 
                 
                 ; ***** PORTB ************************
                 ; PORTCR - Port Control Register
                 .equ	BBMB	= 1	; Break-Before-Make Mode Enable
                 
                 ; PUEB - Pull-up Enable Control Register
                 .equ	PUEB0	= 0	; 
                 .equ	PUEB1	= 1	; 
                 .equ	PUEB2	= 2	; 
                 .equ	PUEB3	= 3	; 
                 
                 ; PORTB - Input Pins, Port B
                 .equ	PORTB0	= 0	; 
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; 
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; 
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; 
                 .equ	PB3	= 3	; For compatibility
                 
                 ; DDRB - Data Direction Register, Port B
                 .equ	DDB0	= 0	; 
                 .equ	DDB1	= 1	; 
                 .equ	DDB2	= 2	; 
                 .equ	DDB3	= 3	; 
                 
                 ; PINB - Port B Data register
                 .equ	PINB0	= 0	; 
                 .equ	PINB1	= 1	; 
                 .equ	PINB2	= 2	; 
                 .equ	PINB3	= 3	; 
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register A
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 
                 ; EIMSK - External Interrupt Mask register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 
                 ; EIFR - External Interrupt Flag register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 
                 ; PCMSK - Pin Change Mask Register
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TCCR0A - Timer/Counter 0 Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode for Channel B bit 0
                 .equ	COM0B1	= 5	; Compare Output Mode for Channel B bit 1
                 .equ	COM0A0	= 6	; Compare Output Mode for Channel A bit 0
                 .equ	COM0A1	= 7	; Compare Output Mode for Channel A bit 1
                 
                 ; TCCR0B - Timer/Counter 0 Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; Waveform Generation Mode
                 .equ	WGM03	= 4	; Waveform Generation Mode
                 .equ	ICES0	= 6	; Input Capture Edge Select
                 .equ	ICNC0	= 7	; Input Capture Noise Canceler
                 
                 ; TCCR0C - Timer/Counter 0 Control Register C
                 .equ	FOC0B	= 6	; Force Output Compare for Channel B
                 .equ	FOC0A	= 7	; Force Output Compare for Channel A
                 
                 ; TIMSK0 - Timer Interrupt Mask Register 0
                 .equ	TOIE0	= 0	; Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Output Compare A Match Interrupt Enable
                 .equ	OCIE0B	= 2	; Output Compare B Match Interrupt Enable
                 .equ	ICIE0	= 5	; Input Capture Interrupt Enable
                 
                 ; TIFR0 - Overflow Interrupt Enable
                 .equ	TOV0	= 0	; Timer Overflow Flag
                 .equ	OCF0A	= 1	; Timer Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer Output Compare Flag 0B
                 .equ	ICF0	= 5	; Input Capture Flag
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSR	= 0	; Prescaler Reset
                 .equ	TSM	= 7	; Timer Synchronization Mode
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control and Status Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timer Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timer Interrupt Flag
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lockbit
                 .equ	LB2	= 1	; Lockbit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; BYTE0 fuse bits
                 .equ	RSTDISBL	= 0	; Disable external reset
                 .equ	WDTON	= 1	; Watch dog timer always on
                 .equ	CKOUT	= 2	; Output external clock
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x01ff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0040
                 .equ	SRAM_SIZE	= 32
                 .equ	RAMEND	= 0x005f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x0000
                 .equ	EEPROMEND	= 0x0000
                 
                 ; ***** MEMORY MAPPED NVM ************************************************
                 .equ	MAPPED_FLASH_START	= 0x4000
                 .equ	MAPPED_LOCKBITS_0	= 0x3f00
                 .equ	MAPPED_CONFIG_0	= 0x3f40
                 .equ	MAPPED_CALIB_0	= 0x3f80
                 .equ	MAPPED_SIGN_0	= 0x3fc0
                 .equ	MAPPED_SIGN_1	= 0x3fc1
                 .equ	MAPPED_SIGN_2	= 0x3fc2
                 .equ	MAPPED_FLASH_SIZE	= 0x0400
                 .equ	MAPPED_FLASH_END	= 0x43ff
                 #pragma AVRPART MEMORY PROG_FLASH 1024
                 #pragma AVRPART MEMORY EEPROM 0
                 #pragma AVRPART MEMORY INT_SRAM SIZE 32
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x40
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	PAGESIZE	= 16
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                 .equ	PCI0addr	= 0x0002	; Pin Change Interrupt Request 0
                 .equ	ICP0addr	= 0x0003	; Timer/Counter0 Input Capture
                 .equ	OVF0addr	= 0x0004	; Timer/Counter0 Overflow
                 .equ	OC0Aaddr	= 0x0005	; Timer/Counter Compare Match A
                 .equ	OC0Baddr	= 0x0006	; Timer/Counter Compare Match B
                 .equ	ACIaddr	= 0x0007	; Analog Comparator
                 .equ	WDTaddr	= 0x0008	; Watchdog Time-out
                 .equ	VLMaddr	= 0x0009	; Vcc Voltage Level Monitor
                 
                 .equ	INT_VECTORS_SIZE	= 10	; size in words
                 
                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                 
                 #endif  /* _TN9DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 ;Need help? See the GCBASIC forums at http://sourceforge.net/projects/gcbasic/forums,
                 ;check the documentation or email w_cholmondeley at users dot sourceforge dot net.
                 
                 ;********************************************************************************
                 
                 ;Chip Model: TINY9
                 ;Assembler header file
                 .INCLUDE "tn9def.inc"
                 
                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny9.xml *************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "tn9def.inc"
                 ;* Title             : Register/Bit Definitions for the ATtiny9
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATtiny9
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _TN9DEF_INC_
                 #endif  /* _TN9DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 ;SREG bit names (for AVR Assembler compatibility, GCBASIC uses different names)
                 #define C 0
                 #define H 5
                 #define I 7
                 #define N 2
                 #define S 4
                 #define T 6
                 #define V 3
                 #define Z 1
                 
                 ;********************************************************************************
                 
                 ;Set aside memory locations for variables
                 .EQU	MYSTRING=64
                 .EQU	SERDLYCNT=84
                 .EQU	STRINGPOINTER=85
                 .EQU	STXDATABYTE=86
                 
                 ;********************************************************************************
                 
                 ;Register variables
                 .DEF	DELAYTEMP=r25
                 .DEF	DELAYTEMP2=r26
                 .DEF	SYSCALCTEMPA=r22
                 .DEF	SYSCALCTEMPX=r16
                 .DEF	SYSREADA=r30
                 .DEF	SYSREADA_H=r31
                 .DEF	SYSSTRINGA=r26
                 .DEF	SYSSTRINGA_H=r27
                 .DEF	SYSSTRINGB=r28
                 .DEF	SYSSTRINGB_H=r29
                 .DEF	SYSSTRINGLENGTH=r25
                 .DEF	SYSVALUECOPY=r21
                 .DEF	SYSWAITTEMPMS=r29
                 .DEF	SYSWAITTEMPMS_H=r30
                 
                 ;********************************************************************************
                 
                 ;Vectors
                 ;Interrupt vectors
                 .ORG	0
000000 c009      	rjmp	BASPROGRAMSTART ;Reset
                 .ORG	1
000001 9518      	reti	;INT0
                 .ORG	2
000002 9518      	reti	;PCINT0
                 .ORG	3
000003 9518      	reti	;TIM0_CAPT
                 .ORG	4
000004 9518      	reti	;TIM0_OVF
                 .ORG	5
000005 9518      	reti	;TIM0_COMPA
                 .ORG	6
000006 9518      	reti	;TIM0_COMPB
                 .ORG	7
000007 9518      	reti	;ANA_COMP
                 .ORG	8
000008 9518      	reti	;WDT
                 
                 ;********************************************************************************
                 
                 ;Start of program memory page 0
                 .ORG	10
                 BASPROGRAMSTART:
                 ;Initialise stack
00000a e050      	ldi	SysValueCopy,high(RAMEND)
00000b bf5e      	out	SPH, SysValueCopy
00000c e55f      	ldi	SysValueCopy,low(RAMEND)
00000d bf5d      	out	SPL, SysValueCopy
                 ;Call initialisation routines
00000e d01e      	rcall	INITSYS
00000f d031      	rcall	STX1PINSETUP
                 
                 ;Start of the main program
                 ;''A demonstration program for GCB
                 ;''---------------------------------------------------------------------------------
                 ;''This program uses the SoftSerial library for serial sending and receiving.
                 ;'' SoftSerial uses ASM routines for minimal overhead.
                 ;'' Ser1Receive stops programm execution until a startbit-impulse is detected.
                 ;'' See other samples how to realize timeouts or interrupt-driven receiving.
                 ;'':
                 ;''@author  Evan Venn
                 ;''@licence GPL
                 ;''@version 1.0
                 ;''@date    11/06/2020
                 ;''********************************************************************************
                 ;----- Configuration
                 ;----- Include library
                 ;----- Config Serial UART :
                 ;#define SER1_BAUD 600    ; baudrate must be defined
                 ;#define SER1_DATABITS 8    ; databits optional (default = 8)
                 ;#define SER1_STOPBITS 1    ; stopbits optional (default = 1)
                 ;#define SER1_INVERT Off    ; inverted polarity optional (default = Off)
                 ;Config I/O ports for transmitting:
                 ;#define SER1_TXPORT PORTB  ; I/O port (without .bit) must be defined
                 ;#define SER1_TXPIN 1       ; portbit  must be defined
                 ;Config I/O ports for receiving:
                 ;NOTE:  RX is commented out until we have resolved the LDS/STS issue
                 ;#define SER1_RXPORT PORTB  ; I/O port (without .bit) must be defined
                 ;#define SER1_RXPIN 2       ; portbit  must be defined
                 ;#define SER1_RXNOWAIT Off  ; don't wait for stopbit optional (default = Off)
                 ;----- Variables
                 ;Dim RecByte As Byte
                 ;Dim myString as String * 19
                 ;myString = "Please send a byte!"
000010 e4c0      	ldi	SysStringB,low(MYSTRING)
000011 e0d0      	ldi	SysStringB_H,high(MYSTRING)
000012 ecee      	ldi	SysReadA,low(StringTable1<<1)
000013 e0f0      	ldi	SysReadA_H,high(StringTable1<<1)
000014 d039      	rcall	SysReadString
                 ;----- Main body of program commences here.
                 ;/*
                 ;Repeat 2
                 ;Ser1Send 10   'new line in Terminal
                 ;Ser1Send 13
                 ;end Repeat
                 ;Repeat 20
                 ;Ser1Print myString  'send a text
                 ;Ser1Send myString( 19 )
                 ;Ser1Send 10   'new line in Terminal
                 ;Ser1Send 13
                 ;End Repeat
                 ;*/
                 ;dir portb.0 out
000015 9a08      	sbi	DDRB,0
                 ;Do
                 SysDoLoop_S1:
                 ;pulseout portb.0, 100 ms
                 ;Macro Source: stdbasic.h (185)
                 ;Set Pin On
000016 9a10      	sbi	PORTB,0
                 ;Wait Time
000017 e6d4      	ldi	SysWaitTempMS,100
000018 e0e0      	ldi	SysWaitTempMS_H,0
000019 d007      	rcall	Delay_MS
                 ;Set Pin Off
00001a 9810      	cbi	PORTB,0
                 ;wait 100 ms
                 ;Ser1Send "."
00001b e25e      	ldi	SysValueCopy,46
00001c ab56      	sts	STXDATABYTE,SysValueCopy
00001d d012      	rcall	SER1SEND
                 ;Loop
00001e cff7      	rjmp	SysDoLoop_S1
                 SysDoLoop_E1:
                 ;
                 ;Do Forever
                 ;
                 ;RecByte = Ser1Receive      'receive one byte - wait until detecting startbit
                 ;Ser1Send  13               'new line in Terminal
                 ;Ser1Send  10               '
                 ;Ser1Print "You sent: "  'send a text
                 ;Ser1Send RecByte           'send the sign representing the byte
                 ;
                 ;Loop
                 ;Sub to resolve oscillator
                 ;#startup Init
                 BASPROGRAMEND:
00001f 9588      	sleep
000020 cffe      	rjmp	BASPROGRAMEND
                 
                 ;********************************************************************************
                 
                 Delay_MS:
000021 95e3      	inc	SysWaitTempMS_H
                 DMS_START:
000022 e6af      	ldi	DELAYTEMP2,111
                 DMS_OUTER:
000023 e092      	ldi	DELAYTEMP,2
                 DMS_INNER:
000024 959a      	dec	DELAYTEMP
000025 f7f1      	brne	DMS_INNER
000026 95aa      	dec	DELAYTEMP2
000027 f7d9      	brne	DMS_OUTER
000028 95da      	dec	SysWaitTempMS
000029 f7c1      	brne	DMS_START
00002a 95ea      	dec	SysWaitTempMS_H
00002b f7b1      	brne	DMS_START
00002c 9508      	ret
                 
                 ;********************************************************************************
                 
                 ;Source: system.h (109)
                 INITSYS:
                 ;asm showdebug _Complete_the_chip_setup_of_BSR,ADCs,ANSEL_and_other_key_setup_registers_or_register_bits
                 ;Commence clearing any ANSELx variants in the part, if the ANSEL regsier/bit exists
                 ;End  clearing ANSEL
                 ;Turn off all ports
                 ;PORTB = 0
00002d e050      	ldi	SysValueCopy,0
00002e b952      	out	PORTB,SysValueCopy
00002f 9508      	ret
                 
                 ;********************************************************************************
                 
                 ;Source: SoftSerialCh1.h (172)
                 SER1SEND:
                 ;*** Code for sending a byte is here!
                 ;*** Code for PIC:
                 ;*** Code for AVR:
                 ;** AVR; send to channel:
                 ;lds R23,STxDataByte               ;load DataByte to register
000030 a376      	lds	R23,STXDATABYTE
                 ;ldi R26,SER1_DATABITS+2           ;load number of DataBits to register (1 start + N data + 1 stop)
000031 e0aa      	ldi	R26,8+2
                 ;com R23                           ;invert DataBits and set Carry to 1
000032 9570      	com	R23
                 STX1LOOP:
                 ;10 cycle loop + delay per byte
                 ;brcc STx1One                     ;jump to STxOne if Carry=0  [ASM]             cycle 1
000033 f408      	brcc	STX1ONE
                 ;Set SER1_TXPORT,SER1_TXPIN Off ;set pin LOW if Carry=1 (translated to: cbi)  cycle 2,3
000034 9811      	cbi	PORTB,1
                 STX1ONE:
                 ;brcs STx1Done                    ;jump to STxDone if Carry=1                   cycle 4,5
000035 f008      	brcs	STX1DONE
                 ;Set SER1_TXPORT,SER1_TXPIN On  ;set pin HIGH if Carry=0 (translated to: cbi) cycle -
000036 9a11      	sbi	PORTB,1
                 STX1DONE:
                 ;--- start short delay --------
                 ;ldi R24, STX1_DELAY            ;load delaycounter to register [ASM]          cycle 6
000037 e288      	ldi	R24, 40
                 STX1DELAY:
                 ;delay-loop = (3 cycle * delaycounter) -1
                 ;dec R24                        ;decrement delaycounter
000038 958a      	dec	R24
                 ;brne STx1Delay                  ;loop to STxDelay until delaycounter=0
000039 f7f1      	brne	STX1DELAY
                 ;--- end short delay ----------
                 ;--- start long delay --------
                 ;Sub_SerLongDelay(STX1_DELAYH)  ;process long delay
00003a e052      	ldi	SysValueCopy,2
00003b ab54      	sts	SERDLYCNT,SysValueCopy
00003c d007      	rcall	SUB_SERLONGDELAY
                 ;--- end long delay ----------
                 ;lsr R23                         ;shift next DataBit to Carry  [ASM]  cycle 7
00003d 9576      	lsr	R23
                 ;dec R26                         ;decrement bitcounter [ASM]          cycle 8
00003e 95aa      	dec	R26
                 ;brne STx1Loop                    ;jump to STxLoop and transmit next bit until bitcounter=0  [ASM] cycle 9,10
00003f f799      	brne	STX1LOOP
                 ;* Add additional stopbit
000040 9508      	ret
                 
                 ;********************************************************************************
                 
                 ;Source: SoftSerialCh1.h (155)
                 STX1PINSETUP:
                 ;*** Process pin-direction and -polarity for sending on programmstart:
                 ;Dir SER1_TXPORT.SER1_TXPIN Out       '... make it output
000041 9a09      	sbi	DDRB,1
                 ;Set SER1_TXPORT.SER1_TXPIN On      '... set HIGH to make the first startbit recognizable
000042 9a11      	sbi	PORTB,1
                 ;#ifdef PIC
                 ;nop                                'otherwise the first 2 bytes are garbage !?
                 ;#endif
000043 9508      	ret
                 
                 ;********************************************************************************
                 
                 ;Source: softserial.h (84)
                 SUB_SERLONGDELAY:
                 ;Dim  SerDlyCntI As Byte
                 ;Calling & returning from Sub:  4 cycles
                 ;loading TxCntDly            :  1 cycles
                 ;--- start outer loop --------------
                 ;lds R25, SerDlyCnt
000044 a394      	lds	R25, SERDLYCNT
                 ;ldi R25, SRX1_DELAYH
                 STXDELAYH:
                 ;ldi R24, 253           ;number of inner delay-loops [GCB]         ;outer loop cycle 1
000045 ef8d      	ldi	R24, 253
                 ;--- start inner loop --------------
                 STXDELAYI:
                 ;dec R24              ;decrement inner delaycounter              ;inner loop cycle 1
000046 958a      	dec	R24
                 ;brne STxDelayI        ;loop to STxDelayI until delaycounter = 0  ;inner loop cycle 2,3
000047 f7f1      	brne	STXDELAYI
                 ;nop                  ;last loop:  no jump -1 cycles; nop +1 cycle
000048 0000      	nop
                 ;--- end inner loop -----------------
                 ;dec R25               ;decrement outer delaycounter               ;outer loop cycle 2
000049 959a      	dec	R25
                 ;nop                                                               ;outer loop cycle 3
00004a 0000      	nop
                 ;nop                                                               ;outer loop cycle 4
00004b 0000      	nop
                 ;brne STxDelayH          ;loop to STxDelayH until delaycounter = 0   ;outer loop cycle 5,6
00004c f7c1      	brne	STXDELAYH
                 ;--- end outer loop ---------------
00004d 9508      	ret
                 
                 ;********************************************************************************
                 
                 ;Source: system.h (1300)
                 SYSREADSTRING:
                 ;Dim SysCalcTempA As Byte
                 ;Dim SysStringLength As Byte
                 ;Dim SysCalcTempX As Byte
                 ;Get length
                 ;lpm SysCalcTempA, Z+
                 ;Instance 1
                 ;added 0x4000 to address PROGMEM by setting the one bit
                 ;SYSREADA_H.6  = 1
00004e 64f0      	sbr	 SYSREADA_H,1<<6
00004f 8100      	ld	SysCalcTempX, z
                 ;mov SysCalcTempA, SysCalcTempX
000050 2f60      	mov	SYSCALCTEMPA, SYSCALCTEMPX
                 ;SysReadA += 1
000051 95e3      	inc	SYSREADA
000052 f409      	brne	PC + 2
000053 95f3      	inc	SYSREADA_H
                 ;st Y+, SysCalcTempA
000054 9369      	st	Y+, SYSCALCTEMPA
                 ;rjmp SysStringReadCheck
000055 c006      	rjmp	SYSSTRINGREADCHECK
                 SYSREADSTRINGPART:
                 ;lpm SysCalcTempA, Z+
                 ;Instance 2
000056 8100      	ld	SysCalcTempX, z
                 ;mov SysCalcTempA, SysCalcTempX
000057 2f60      	mov	SYSCALCTEMPA, SYSCALCTEMPX
                 ;SysReadA += 1
000058 95e3      	inc	SYSREADA
000059 f409      	brne	PC + 2
00005a 95f3      	inc	SYSREADA_H
                 ;add SysStringLength, SysCalcTempA
00005b 0f96      	add	SYSSTRINGLENGTH, SYSCALCTEMPA
                 ;Check length
                 SYSSTRINGREADCHECK:
                 ;If length is 0, exit
                 ;cpi SysCalcTempA, 0
00005c 3060      	cpi	SYSCALCTEMPA, 0
                 ;brne SysStringRead
00005d f409      	brne	SYSSTRINGREAD
                 ;ret
00005e 9508      	ret
                 ;Copy
                 SYSSTRINGREAD:
                 ;Copy char
                 ;lpm SysCalcTempX, Z+
                 ;Instance 3
00005f 8100      	ld	SysCalcTempX, z
                 ;SysReadA += 1
000060 95e3      	inc	SYSREADA
000061 f409      	brne	PC + 2
000062 95f3      	inc	SYSREADA_H
                 ;st Y+, SysCalcTempX
000063 9309      	st	Y+, SYSCALCTEMPX
                 ;dec SysCalcTempA
000064 956a      	dec	SYSCALCTEMPA
                 ;brne SysStringRead
000065 f7c9      	brne	SYSSTRINGREAD
000066 9508      	ret
                 
                 ;********************************************************************************
                 
                 SysStringTables:
                 
                 StringTable1:
000067 5013
000068 656c
000069 7361
00006a 2065
00006b 6573
00006c 646e
00006d 6120
00006e 6220
00006f 7479
000070 2165      .DB	19,80,108,101,97,115,101,32,115,101,110,100,32,97,32,98,121,116,101,33
                 
                 
                 StringTable2:
000071 2e01      .DB	1,46
                 
                 
                 ;********************************************************************************
                 
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny9" register use summary:
r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 r5 :   0 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 r13:   0 r14:   0 r15:   0 
r16:   6 r17:   0 r18:   0 r19:   0 r20:   0 r21:  10 r22:   6 r23:   3 
r24:   4 r25:   5 r26:   4 r27:   0 r28:   1 r29:   3 r30:   7 r31:   5 
x  :   0 y  :   2 z  :   3 
Registers used: 13 out of 35 (37.1%)

"ATtiny9" instruction use summary:
.lds.l:   0 .sts.l:   0 adc   :   0 add   :   1 and   :   0 andi  :   0 
asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 brcc  :   1 
brcs  :   1 breq  :   0 brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 
brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 brne  :  13 brpl  :   0 
brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 
bst   :   0 cbi   :   2 cbr   :   0 clc   :   0 clh   :   0 cli   :   0 
cln   :   0 clr   :   0 cls   :   0 clt   :   0 clv   :   0 clz   :   0 
com   :   1 cp    :   0 cpc   :   0 cpi   :   1 cpse  :   0 dec   :   9 
eor   :   0 icall :   0 ijmp  :   0 in    :   0 inc   :   7 ld    :   3 
ldd   :   0 ldi   :  16 lds   :   4 lsl   :   0 lsr   :   1 mov   :   2 
neg   :   0 nop   :   3 or    :   0 ori   :   0 out   :   3 pop   :   0 
push  :   0 rcall :   6 ret   :   7 reti  :   8 rjmp  :   4 rol   :   0 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :   5 sbic  :   0 sbis  :   0 
sbr   :   1 sbrc  :   0 sbrs  :   0 sec   :   0 seh   :   0 sei   :   0 
sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 
sleep :   1 st    :   2 std   :   0 sts   :   4 sub   :   0 subi  :   0 
swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 25 out of 99 (25.3%)

"ATtiny9" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0000e4    204     22    226    1024  22.1%
[.dseg] 0x000040 0x000060      0      0      0      32   0.0%
[.eseg] 0x000000 0x000000      0      0      0       0      -

Assembly complete, 0 errors, 10 warnings
