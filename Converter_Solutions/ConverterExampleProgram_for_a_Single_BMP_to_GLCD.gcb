'''A demonstration program for GCGB and GCB.
'''--------------------------------------------------------------------------------------------------------------------------------
'''This program shows the converter capabilities of Great Cow Basic by converting an external BMP file to a GCB table.
'''This program will convert a graphical BMP file to a GCB table.  The table will be then used as the data source of the GLCD device.
'''This program requires the BMP2GCB.exe utility and the configuration file to be installed in the GCBasic converters folder.  The source BMP should be in the same folder.
'''The GLCD should be connected as shown in the program.  The GLCD connection can be changed to suit your specific configuration.
'''@author 	EvanV
'''@licence	GPL
'''@version	1.0a
'''@date   	09.3.2015
'''********************************************************************************

' ----- Configuration

#CHIP 16f877a, 20
#OPTION Explicit
#OPTION Explicit
#INCLUDE <glcd.h>

' ----- Constants
' No Constants specified in this example.
' See below

' ----- Define Hardware settings
'  Setup GLCD
#DEFINE GLCD_TYPE GLCD_TYPE_KS0108
#DEFINE GLCD_WIDTH 128
#DEFINE GLCD_HEIGHT 64


'CS1, CS2 can be reversed on some devices
#DEFINE GLCD_CS1 PORTa.4
#DEFINE GLCD_CS2 PORTa.5
'D0 to pin 7 on LCD
#DEFINE GLCD_DB0 PORTD.0
'D1 to pin 8 on LCD
#DEFINE GLCD_DB1 PORTD.1
'D2 to pin 9 on LCD
#DEFINE GLCD_DB2 PORTD.2
'D3 to pin 10 on LCD
#DEFINE GLCD_DB3 PORTD.3
'D4 to pin 11 on LCD
#DEFINE GLCD_DB4 PORTD.4
'D5 to pin 12 on LCD
#DEFINE GLCD_DB5 PORTD.5
'D6 to pin 13 on LCD
#DEFINE GLCD_DB6 PORTD.6
'D7 to pin 14 on LCD
#DEFINE GLCD_DB7 PORTD.7


#DEFINE GLCD_RS PORTa.0
#DEFINE GLCD_Enable PORTA.1
#DEFINE GLCD_RW PORTA.2
#DEFINE GLCD_RESET PORTA.3


' ----- Variables
' These must be WORDs as this a large table.
Dim TableReadPosition, TableLen As Word
' either 0 or 1.  Needs to match the background pixel state.
OptmiseGLCDDraw  = 0

Dim objwidth, objheight, wholebytes, hcount, widthcount, wbyte, OptmiseGLCDDraw, OnPageBoundary As Byte
Dim GLCDYPOS, glcdxpos, oldglcdxpos, GLCDX, GLCDY As Word
Dim WHOLEYBYTES, CURRPAGE, MAXHEIGHT, CURRCHARROW As Byte


' ----- Quick Command Reference:
#INCLUDE <..\converters\anobium.bmp>
' define the BMP here to minimise any changes to code.  Simply change this define your specific filename
'
' If the include statement has the file specific of Anobium then define TestDataSource as Anobium. And, therefore if the file specific of BatteryMon then define TestDataSource as BatteryMon.

#DEFINE TestDataSource Anobium



' ----- Main body of program commences here.
TableReadPosition = 1
ReadTable TestDataSource, TableReadPosition, objwidth: TableReadPosition++
ReadTable TestDataSource, TableReadPosition, objHeight: TableReadPosition++

'Draw at the upper left corner is set with GLCDXPos, GLCDYPos
GLCDXPos = 0
GLCDYPos = 0

oldGLCDXPos = GLCDXPos
TableReadPosition = 3

' Number of whole bytes within Y Axis.  This is integer maths!
WholeYBytes = objHeight /  8

' If GLCDYPos as a memory page boundary.  Used to fast write the byte method
onPageBoundary = ( GLCDYPos % 8 ) = 0

If WholeYBytes <> 0 Then

    ' counter to number of whole bytes
    For hCount = 0 To (WholeYBytes - 1)

        'Note: It is safe to use GLCDY and X here as PSET is not called when this is used as a variable
        GLCDY = GLCDYPos+hCount
        ' increment thru bytes horizontally
        For widthCount = 0 To (objwidth - 1)
            ' get the next byte
            ReadTable TestDataSource, TableReadPosition, wByte: TableReadPosition++
            If wByte <> OptmiseGLCDDraw Then
                ' if the incoming byte is the same as the background, dont draw
                'So,  we have to draw this byte
                
                'If a a page boundary  this is a faster draw routine
                
                If onPageBoundary = TRUE Then
                    'use fast draw byte - essentially just write the data out, no, reading whats there.
                    GLCDX = GLCDXPos+widthCount
                    If GLCDX.6 = Off Then
                        Set GLCD_CS2 On
                        Set GLCD_CS1 Off
                    End If
                    If GLCDX.6 = On Then
                        Set GLCD_CS1 On
                        GLCDX -= 64
                        Set GLCD_CS2 Off
                    End If

                    'Select page
                    CurrPage = GLCDY / 8
                    Set GLCD_RS Off
                    GLCDWriteByte b'10111000' OR CurrPage

                    'Select column
                    GLCDWriteByte 64 OR GLCDX
                    'Write data back
                    Set GLCD_RS On
                    GLCDWriteByte wByte

                Else

                    'slow draw method using X Y position and interate throught the bits
                    For CurrCharRow = 0 To 7
                        If wByte.0 = 0 Then
                            Pset GLCDXPos+widthCount, CurrCharRow + GLCDYPos, GLCDBackground
                        Else
                            Pset GLCDXPos+widthCount, CurrCharRow + GLCDYPos, GLCDForeground
                        End If
                        Rotate wByte Right
                    Next
                End If

            End If

        Next widthCount

        GLCDXPos =  oldGLCDXPos
        GLCDYPos = GLCDYPos + 8

    Next hCount

End If

' calculate the remaining bits
maxHeight = objHeight % 8

'writes and remaining bits, if any
If maxHeight <> 0 Then

    For widthCount = 0 To objwidth - 1
        ReadTable TestDataSource, TableReadPosition, wByte: TableReadPosition++
        'use a slow draw using X Y position and interate throught the bits
        For CurrCharRow = 0 To maxHeight-1
            If wByte.0 = 0 Then
                Pset GLCDXPos+widthCount, ( CurrCharRow + GLCDYPos ), GLCDBackground
            Else
                Pset GLCDXPos+widthCount, ( CurrCharRow + GLCDYPos ), GLCDForeground
            End If
            Rotate wByte Right
        Next
    Next
End If
Set GLCD_CS1 Off
Set GLCD_CS2 Off
End
' ----- Support methods.  Subroutines and Functions
